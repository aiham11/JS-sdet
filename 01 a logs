import org.jsoup.Jsoup;

public void migrateTestStepsWithAttachments(String rallyTestCaseOID, List<JiraTestStep> jiraTestSteps, RallyRestApi rallyApi, Map<Integer, List<String>> embeddedAttachmentsMap) {
    Set<String> processedAttachments = new HashSet<>();

    for (JiraTestStep jiraTestStep : jiraTestSteps) {
        System.out.println("Printing the Jira test steps: " + jiraTestStep);
        try {
            JsonObject newTestStep = new JsonObject();
            newTestStep.addProperty("TestCase", rallyTestCaseOID);
            newTestStep.addProperty("StepIndex", jiraTestStep.getIndex() + 1);  // Adjust the index to start from 1

            // Combine "Step" and "Test Data" fields into the "Input" field in Rally
            String inputField = cleanText((jiraTestStep.getStep() != null ? jiraTestStep.getStep() : "") +
                                (jiraTestStep.getTestData() != null ? "\n" + jiraTestStep.getTestData() : ""));
            
            // Map "Expected Result" field from Jira directly to Rally's "Expected Result" after cleaning the text
            String expectedResultField = cleanText(jiraTestStep.getExpectedResult());

            // Check and adjust Input field if it exceeds 2048 characters
            if (inputField != null && inputField.length() > 2048) {
                logger.warn("Input field length exceeds 2048 characters. Removing formatting to fit the allowed limit.");
                inputField = removeHtmlTags(inputField); // Remove formatting
                if (inputField.length() > 2048) {
                    inputField = inputField.substring(0, 2048); // Truncate if still too long
                }
            }
            newTestStep.addProperty("Input", inputField);

            // Check and adjust Expected Result field if it exceeds 2048 characters
            if (expectedResultField != null && expectedResultField.length() > 2048) {
                logger.warn("Expected result field length exceeds 2048 characters. Removing formatting to fit the allowed limit.");
                expectedResultField = removeHtmlTags(expectedResultField); // Remove formatting
                if (expectedResultField.length() > 2048) {
                    expectedResultField = expectedResultField.substring(0, 2048); // Truncate if still too long
                }
            }
            newTestStep.addProperty("ExpectedResult", expectedResultField);

            // Handle embedded attachments specific to this test step
            List<String> stepEmbeddedAttachments = embeddedAttachmentsMap.get(jiraTestStep.getIndex());
            if (stepEmbeddedAttachments != null && !stepEmbeddedAttachments.isEmpty()) {
                for (String embeddedPath : stepEmbeddedAttachments) {
                    if (!processedAttachments.contains(embeddedPath)) {
                        // Extract the filename from the full path
                        String filename = embeddedPath.substring(embeddedPath.lastIndexOf("\\") + 1);
                        String[] attachmentParts = filename.split("_");

                        if (attachmentParts.length > 0) {
                            try {
                                // Extract the step number from the first part of the filename
                                int attachmentStepNumber = Integer.parseInt(attachmentParts[0]);

                                // Check if this attachment corresponds to the current step
                                if (attachmentStepNumber == jiraTestStep.getIndex() + 1) {  // Ensure the matching is correct
                                    String attachmentURL = attachFileToRallyTestCase(rallyApi, rallyTestCaseOID, embeddedPath);
                                    String attachmentOID = extractOID(attachmentURL);
                                    if (attachmentOID != null) {
                                        // Determine whether the attachment belongs to Input or ExpectedResult
                                        if (filename.contains("testData") || filename.contains("description")) {
                                            newTestStep.addProperty("Input", newTestStep.get("Input").getAsString() + " <img src='https://rally1.rallydev.com/slm/attachment/" + attachmentOID + "/content'/>");
                                            logger.info("Attachment added to Input field for Test Step " + (jiraTestStep.getIndex() + 1) + ": " + embeddedPath);
                                        } else if (filename.contains("expectedResult")) {
                                            newTestStep.addProperty("ExpectedResult", newTestStep.get("ExpectedResult").getAsString() + " <img src='https://rally1.rallydev.com/slm/attachment/" + attachmentOID + "/content'/>");
                                            logger.info("Attachment added to Expected Result field for Test Step " + (jiraTestStep.getIndex() + 1) + ": " + embeddedPath);
                                        } else {
                                            logger.warn("Attachment name does not contain a recognized field identifier (testData, description, expectedResult): " + embeddedPath);
                                        }
                                    }
                                    processedAttachments.add(embeddedPath);  // Mark this attachment as processed
                                }
                            } catch (NumberFormatException e) {
                                logger.error("Failed to parse step number from attachment name: " + filename, e);
                            }
                        }
                    }
                }
            }

            CreateRequest createRequest = new CreateRequest("TestcaseStep", newTestStep);
            CreateResponse createResponse = rallyApi.create(createRequest);

            if (createResponse.wasSuccessful()) {
                String testStepURL = createResponse.getObject().get("_ref").getAsString();
                String testStepOID = extractOID(testStepURL);
                logger.info("Successfully created test step in Rally with OID: " + testStepOID + " for TestCase: " + rallyTestCaseOID);
            } else {
                String[] errors = createResponse.getErrors();
                logger.error("Failed to create test step in Rally: " + String.join(", ", errors));
            }
        } catch (IOException e) {
            logger.error("Exception occurred while creating test step in Rally", e);
        }
    }
}

private String removeHtmlTags(String input) {
    return Jsoup.parse(input).text();
}













private String removeHtmlTags(String input) {
    if (input == null || input.isEmpty()) {
        return input;
    }

    // Replace <br>, <p>, and <div> tags with newlines before removing other tags
    input = input.replaceAll("(?i)<br\\s*/?>", "\n"); // Replace <br> with newline
    input = input.replaceAll("(?i)</p>", "\n");       // Replace closing </p> with newline
    input = input.replaceAll("(?i)</div>", "\n");     // Replace closing </div> with newline

    // Remove other HTML tags
    return Jsoup.parse(input).text();
}











private String removeHtmlTags(String input) {
    if (input == null || input.isEmpty()) {
        return input;
    }

    // First, replace block-level tags with newlines
    input = input.replaceAll("(?i)<br\\s*/?>", "\n");  // Replace <br> with newline
    input = input.replaceAll("(?i)</p>", "\n");        // Replace </p> with newline
    input = input.replaceAll("(?i)</div>", "\n");      // Replace </div> with newline
    input = input.replaceAll("(?i)<div[^>]*>", "\n");  // Replace <div> with newline
    input = input.replaceAll("(?i)<p[^>]*>", "\n");    // Replace <p> with newline

    // Then, remove all other HTML tags
    input = Jsoup.parse(input).text();

    // Finally, replace multiple newlines with a single newline to avoid too many line breaks
    input = input.replaceAll("\n+", "\n");

    return input.trim();
}














import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.select.NodeTraversor;
import org.jsoup.select.NodeVisitor;

public String removeHtmlTagsPreservingNewlines(String input) {
    if (input == null || input.isEmpty()) {
        return input;
    }

    Document doc = Jsoup.parse(input);
    doc.outputSettings(new Document.OutputSettings().prettyPrint(false)); // Prevent Jsoup from formatting the output
    doc.select("br").append("\\n");  // Replace <br> with \n (newline)
    doc.select("p").prepend("\\n\\n"); // Add newline before <p> tags

    // Traverse the document to replace \n with actual newlines and extract the text
    String text = new StringBuilder().toString();
    for (Element e : doc.body().select("*")) {
        if (e.ownText().contains("\\n")) {
            e.text(e.ownText().replace("\\n", "\n"));
        }
    }

    // Now, get the text with newlines preserved
    return doc.text().replace("\\n", "\n").trim();
}













import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

public String removeHtmlTagsPreservingNewlines(String input) {
    if (input == null || input.isEmpty()) {
        return input;
    }

    Document doc = Jsoup.parse(input);

    // Replace <br> tags with newlines
    Elements brElements = doc.select("br");
    for (Element br : brElements) {
        br.after("\n");
    }

    // Replace <p> tags with double newlines
    Elements pElements = doc.select("p");
    for (Element p : pElements) {
        p.before("\n\n");
    }

    // Return the cleaned text
    return doc.text().replaceAll("\\n{3,}", "\n\n").trim(); // Replace multiple newlines with a maximum of two
}










import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

public String removeHtmlTagsPreservingNewlines(String input) {
    if (input == null || input.isEmpty()) {
        return input;
    }

    // Parse the HTML content
    Document doc = Jsoup.parse(input);

    // Replace <br> tags with newlines
    Elements brElements = doc.select("br");
    for (Element br : brElements) {
        br.after("\\n"); // Insert a literal newline
    }

    // Handle paragraph breaks by replacing <p> with double newlines
    Elements pElements = doc.select("p");
    for (Element p : pElements) {
        p.before("\\n\\n"); // Insert two newlines before each paragraph
    }

    // Get the plain text content with newlines preserved
    String cleanedText = doc.text().replace("\\n", "\n"); // Convert literal newlines to actual newlines

    return cleanedText.trim();
}












import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

public String removeHtmlTagsPreservingNewlines(String input) {
    if (input == null || input.isEmpty()) {
        return input;
    }

    // Parse the HTML content
    Document doc = Jsoup.parse(input);

    // Replace <br> tags with newlines
    Elements brElements = doc.select("br");
    for (Element br : brElements) {
        br.before("\\n"); // Insert a literal newline
        br.remove(); // Remove the <br> tag after adding the newline
    }

    // Handle paragraphs and other block elements by replacing with newlines
    Elements blockElements = doc.select("p, div, ul, ol, li, h1, h2, h3, h4, h5, h6, blockquote");
    for (Element block : blockElements) {
        block.before("\\n"); // Insert a newline before each block element
        block.after("\\n");  // Insert a newline after each block element
    }

    // Get the plain text content with newlines preserved
    String cleanedText = doc.text().replace("\\n", "\n"); // Convert literal newlines to actual newlines

    return cleanedText.trim();
}










