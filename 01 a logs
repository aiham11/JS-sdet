Here are the updated classes with the changes incorporated based on the issues you shared earlier. The changes include improving JSON validation, adding a retry mechanism for concurrency conflicts, and enhancing error handling.

### `RallyOperation.java`
```java
package com.optum.coe.automation.rally;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.rallydev.rest.RallyRestApi;
import com.rallydev.rest.request.CreateRequest;
import com.rallydev.rest.response.CreateResponse;

public class RallyOperation {

    private String rallyBaseURL;
    private String rallyApiKey;
    private String rallyProjectKey;
    private String rallyUser;

    private static final Logger logger = LogManager.getLogger();

    public RallyOperation() {
        rallyBaseURL = ConfigLoader.getConfigValue("RALLY_BASE_URL");
        rallyApiKey = ConfigLoader.getConfigValue("RALLY_API_KEY");
        rallyProjectKey = ConfigLoader.getConfigValue("RALLY_PROJECT_REF");
        rallyUser = ConfigLoader.getConfigValue("RALLY_USER_REF");
        logger.info("Rally values for the project key " + rallyProjectKey + " are assigned from rally_migration_config.properties file");
        logger.log(Level.getLevel("VERBOSE"), "Loaded values from rally_migration_config.properties file.\nRally Base URL - " + rallyBaseURL + "\nRally Project Reference " + rallyProjectKey);
    }

    public String createRallyTestcase(JsonObject jiraJson) {
        String rallyTestCaseOID = null;
        JsonObject rallyJson = new JsonObject();
        rallyJson.addProperty("projectRef", rallyProjectKey);

        JsonObject testCase = new JsonObject();
        JsonElement nameElement = jiraJson.get("name");
        testCase.addProperty("Name", nameElement != null && !nameElement.isJsonNull() ? nameElement.getAsString() : "Default Test Case Name");

        testCase.addProperty("Method", "Manual");
        JsonElement priorityElement = jiraJson.get("priority");
        testCase.addProperty("Priority", priorityElement != null && !priorityElement.isJsonNull() ? (priorityElement.getAsString().equalsIgnoreCase("Normal") ? "Useful" : priorityElement.getAsString()) : "Default Priority");
        testCase.addProperty("Owner", "/user/" + rallyUser);
        JsonElement statusElement = jiraJson.get("status");
        testCase.addProperty("Ready", statusElement != null && !statusElement.isJsonNull() && statusElement.getAsString().equals("Ready"));

        JsonArray tagsArray = new JsonArray();
        JsonObject tagObject = new JsonObject();
        tagObject.addProperty("_ref", "/tag/56011614555");
        tagObject.addProperty("Name", "Billing and Eligibility");
        tagsArray.add(tagObject);
        testCase.add("Tags", tagsArray);

        String folderPath = jiraJson.get("folder").getAsString();
        String[] folderHierarchy = folderPath.split("/");
        JsonObject testFolder = Utils.createTestFolder(folderHierarchy, rallyProjectKey, rallyBaseURL, rallyApiKey);
        if (testFolder == null) {
            logger.error("Failed to create or retrieve TestFolder during Testcase Creation process in Rally");
            return rallyTestCaseOID;
        }
        rallyJson.add("TestFolder", testFolder);
        rallyJson.add("testCase", testCase);

        String rallyJsonString = new GsonBuilder().setPrettyPrinting().create().toJson(rallyJson);
        RallyRestApi restApi = null;
        try {
            restApi = new RallyRestApi(new URI(rallyBaseURL), rallyApiKey);
            restApi.setApplicationName("CreateTestCaseApp");

            JsonObject jsonData = JsonParser.parseString(rallyJsonString).getAsJsonObject();
            JsonObject testCaseData = jsonData.getAsJsonObject("testCase");
            JsonObject testFolderData = jsonData.getAsJsonObject("TestFolder");

            JsonObject newTestCase = new JsonObject();
            newTestCase.addProperty("Name", testCaseData.get("Name").getAsString());
            newTestCase.addProperty("Project", rallyProjectKey);
            newTestCase.addProperty("Method", testCaseData.get("Method").getAsString());
            newTestCase.addProperty("Priority", testCaseData.get("Priority").getAsString());
            newTestCase.addProperty("Owner", testCaseData.get("Owner").getAsString());
            newTestCase.addProperty("Ready", testCaseData.get("Ready").getAsBoolean());

            JsonArray tagsArrayFromJson = testCaseData.getAsJsonArray("Tags");
            if (tagsArrayFromJson != null) {
                JsonArray newTagsArray = new JsonArray();
                for (JsonElement tagElement : tagsArrayFromJson) {
                    JsonObject tagObjectFromJson = tagElement.getAsJsonObject();
                    String tagRef = tagObjectFromJson.get("_ref").getAsString();
                    JsonObject newTagObject = new JsonObject();
                    newTagObject.addProperty("_ref", tagRef);
                    newTagsArray.add(newTagObject);
                }
                newTestCase.add("Tags", newTagsArray);
            }

            String testFolderRef = testFolderData.get("_ref").getAsString();
            newTestCase.addProperty("TestFolder", testFolderRef);

            CreateRequest createRequest = new CreateRequest("testcase", newTestCase);
            CreateResponse createResponse = restApi.create(createRequest);

            if (createResponse.wasSuccessful()) {
                rallyTestCaseOID = createResponse.getObject().get("_ref").getAsString();
                logger.info("Successfully created test case: " + rallyTestCaseOID);
            } else {
                logger.error("Error occurred creating test case");
                for (String error : createResponse.getErrors()) {
                    logger.error(error);
                }
            }
        } catch (URISyntaxException | IOException e) {
            logger.error("Error in createRallyTestcase method.", e);
        } finally {
            try {
                if (restApi != null) restApi.close();
            } catch (IOException e) {
                logger.error("Error closing Rally API", e);
            }
        }
        return rallyTestCaseOID;
    }

    public List<String> attachFilestoRallyTestcase(String rallyTestCaseOID, List<String> filePaths) {
        List<String> testcaseAttachmentOIDs = new ArrayList<>();
        RallyRestApi rallyApi = null;
        try {
            rallyApi = new RallyRestApi(new URI(rallyBaseURL), rallyApiKey);
            for (String filePath : filePaths) {
                try {
                    String attachmentOID = attachFileToRallyTestCase(rallyApi, rallyTestCaseOID, filePath);
                    if (attachmentOID != null) {
                        testcaseAttachmentOIDs.add(attachmentOID);
                        logger.info("File " + filePath + " attached successfully to test case: " + rallyTestCaseOID);
                    }
                } catch (IOException e) {
                    logger.error("Error attaching file: " + filePath, e);
                }
            }
        } catch (URISyntaxException e) {
            logger.error("Rally Base URL has syntax error.", e);
        } finally {
            try {
                if (rallyApi != null) rallyApi.close();
            } catch (IOException e) {
                logger.error("Error closing Rally API", e);
            }
        }
        return testcaseAttachmentOIDs;
    }

    public String attachFileToRallyTestCase(RallyRestApi rallyApi, String testCaseId, String filePath) throws IOException {
        byte[] fileContent = Files.readAllBytes(Paths.get(filePath));
        String encodedContent = Base64.getEncoder().encodeToString(fileContent);

        String contentType = getContentType(filePath);

        JsonObject attachmentContent = new JsonObject();
        attachmentContent.addProperty("Content", encodedContent);
        CreateRequest attachmentContentRequest = new CreateRequest("AttachmentContent", attachmentContent);
        CreateResponse attachmentContentResponse = rallyApi.create(attachmentContentRequest);
        if (!attachmentContentResponse.wasSuccessful()) {
            logger.error("Error creating AttachmentContent for file: " + filePath + ". Errors: " + Arrays.toString(attachmentContentResponse.getErrors()));
            return null;
        }
        String attachmentContentRef = attachmentContentResponse.getObject().get("_ref").getAsString();

        JsonObject attachment = new JsonObject();
        attachment.addProperty("Artifact", "/testcase/" + testCaseId);
        attachment.addProperty("Content", attachmentContentRef);
        attachment.addProperty("Name", Paths.get(filePath).getFileName().toString());
        attachment.addProperty("Description", "Jira to Rally Migration Automated Attachments");
        attachment.addProperty("ContentType", contentType);
        attachment.addProperty("Size", fileContent.length);
        CreateRequest attachmentRequest = new CreateRequest("Attachment", attachment);
        CreateResponse attachmentResponse = rallyApi.create(attachmentRequest);

        if (attachmentResponse.wasSuccessful()) {
            logger.info("Attachment created successfully for file: " + filePath);
            return attachmentResponse.getObject().get("_ref").getAsString();
        } else {
            logger.error("Error creating Attachment for file: " + filePath + ". Errors: " + Arrays.toString(attachmentResponse.getErrors()));
            return null;
        }


    }

    private String getContentType(String filePath) {
        String extension = filePath.substring(filePath.lastIndexOf('.')).toLowerCase();
        switch (extension) {
            case ".png":
                return "image/png";
            case ".txt":
                return "text/plain";
            case ".jpeg":
            case ".jpg":
                return "image/jpeg";
            case ".xml":
                return "application/xml";
            case ".gif":
                return "image/gif";
            case ".doc":
                return "application/msword";
            case ".docx":
                return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
            case ".xls":
                return "application/vnd.ms-excel";
            case ".xlsx":
                return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            case ".zip":
                return "application/zip";
            default:
                return "application/octet-stream";
        }
    }

    private String sanitizeJsonString(String jsonString) {
        try {
            JsonParser.parseString(jsonString);
            return jsonString;
        } catch (Exception e) {
            logger.warn("Invalid JSON detected, sanitizing: " + jsonString, e);
            return "{}";
        }
    }

    public void migrateTestSteps(String rallyTestCaseRef, List<JiraTestStep> jiraTestSteps, RallyRestApi rallyRestApi, Map<Integer, List<String>> attachmentOIDsMap) {
        Collections.reverse(jiraTestSteps);
        String rallyBaseUrl = ConfigLoader.getConfigValue("RALLY_BASE_URL");

        int maxRetries = 3;

        for (JiraTestStep step : jiraTestSteps) {
            int retryCount = 0;
            boolean success = false;

            while (retryCount < maxRetries && !success) {
                try {
                    JsonObject newTestStep = new JsonObject();
                    newTestStep.addProperty("TestCase", rallyTestCaseRef);
                    newTestStep.addProperty("StepIndex", step.getIndex());

                    String description = sanitizeJsonString(step.getDescription());
                    String expectedResult = sanitizeJsonString(step.getExpectedResult());
                    String testData = sanitizeJsonString(step.getTestData());
                    String attachmentLocation = ConfigLoader.getConfigValue("TEST_STEP_FILE_ATTACHMENT_LOCATION");

                    if (description != null && !description.isEmpty()) {
                        List<String> descriptionAttachmentPaths = Utils.downloadTestStepEmbeddedAttachments(
                            description, 
                            ConfigLoader.getConfigValue("JIRA_API_TOKEN"), 
                            attachmentLocation, 
                            rallyTestCaseRef, 
                            rallyBaseUrl, 
                            "description"
                        );
                        description += Utils.constructAttachmentUrls(descriptionAttachmentPaths);
                    }

                    if (expectedResult != null && !expectedResult.isEmpty()) {
                        List<String> expectedResultAttachmentPaths = Utils.downloadTestStepEmbeddedAttachments(
                            expectedResult, 
                            ConfigLoader.getConfigValue("JIRA_API_TOKEN"), 
                            attachmentLocation, 
                            rallyTestCaseRef, 
                            rallyBaseUrl, 
                            "expectedResult"
                        );
                        expectedResult += Utils.constructAttachmentUrls(expectedResultAttachmentPaths);
                    }

                    if (testData != null && !testData.isEmpty()) {
                        List<String> testDataAttachmentPaths = Utils.downloadTestStepEmbeddedAttachments(
                            testData, 
                            ConfigLoader.getConfigValue("JIRA_API_TOKEN"), 
                            attachmentLocation, 
                            rallyTestCaseRef, 
                            rallyBaseUrl, 
                            "testData"
                        );
                        testData += Utils.constructAttachmentUrls(testDataAttachmentPaths);
                    }

                    newTestStep.addProperty("Input", description);
                    newTestStep.addProperty("ExpectedResult", expectedResult);
                    newTestStep.addProperty("TestData", testData);

                    CreateRequest createRequest = new CreateRequest("testcasestep", newTestStep);
                    CreateResponse createResponse = rallyRestApi.create(createRequest);

                    if (createResponse.wasSuccessful()) {
                        String rallyTestStepOID = createResponse.getObject().get("_ref").getAsString();
                        logger.info("Successfully created test step: " + step.getDescription());
                        success = true;
                    } else {
                        logger.error("Failed to create test step: " + step.getDescription() + ". Error: " + Arrays.toString(createResponse.getErrors()));
                        retryCount++;
                    }
                } catch (ConcurrencyConflictException e) {
                    retryCount++;
                    if (retryCount >= maxRetries) {
                        logger.error("Failed to create test step after " + maxRetries + " attempts due to concurrency conflict.", e);
                    } else {
                        logger.warn("Concurrency conflict occurred, retrying... Attempt: " + retryCount);
                    }
                } catch (Exception e) {
                    logger.error("Exception while creating test step: " + step.getDescription(), e);
                    break;
                }
            }
        }
    }
}
```

### `JiraOperation.java`
```java
package com.optum.coe.automation.rally;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.apache.http.HttpEntity;
import org.apache.http.ParseException;
import org.apache.http.util.EntityUtils;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONArray;
import org.json.JSONObject;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class JiraOperation {
    private String jiraBaseURL;
    private String jiraApiKey;
    private String jiraProjectKey;
    private String max_chunk;
    private String tcFileAttachmentDownloadLocation;
    private static String tsFileAttachmentDownloadLocation;
    private static final Logger logger = LogManager.getLogger();

    public JiraOperation() {
        jiraBaseURL = ConfigLoader.getConfigValue("JIRA_BASE_URL");
        jiraApiKey = ConfigLoader.getConfigValue("JIRA_API_TOKEN");
        jiraProjectKey = ConfigLoader.getConfigValue("JIRA_PROJECT_KEY");
        max_chunk = ConfigLoader.getConfigValue("MAX_VALUE_CHUNK");
        tcFileAttachmentDownloadLocation = ConfigLoader.getConfigValue("TEST_CASE_FILE_ATTACHMENT_LOCATION");
        tsFileAttachmentDownloadLocation = ConfigLoader.getConfigValue("TEST_STEP_FILE_ATTACHMENT_LOCATION");
        logger.info("Jira values for the project key " + jiraProjectKey + " are assigned from rally_migration_config.properties file");
        logger.log(Level.getLevel("VERBOSE"),
                "Below are the values assigned from rally_migration_config.properties file. \nJira Base URL - "
                        + jiraBaseURL + "\nJira Project Key " + jiraProjectKey + "\nMax Chunk value - " + max_chunk
                        + "\nTest Case File Attachment Download location - " + tcFileAttachmentDownloadLocation
                        + "\nTest Step File Attachment location - " + tsFileAttachmentDownloadLocation);
    }

    public ArrayList<String> getJiraNonMigratedTestcaseKeys() {
        ArrayList<String> testCaseKeys = new ArrayList<>();
        String encodedKey = null;
        try {
            encodedKey = java.net.URLEncoder.encode(
                    "projectKey = " + jiraProjectKey
                            + " AND \"Migrate Test to Rally\" = true AND \"TestCase Migrated\" = false",
                    java.nio.charset.StandardCharsets.UTF_8.toString());
        } catch (Exception e) {
            logger.error("Error while encoding a part of URL ", e);
            return testCaseKeys;
        }

        String url = jiraBaseURL + "/rest/atm/1.0/testcase/search?fields=key&maxResults=" + max_chunk + "&query="
                + encodedKey;
        logger.info("String URL to get non-migrated testcase keys from Jira: " + url);

        HttpEntity response = Utils.getJiraResponse(url, jiraApiKey);
        if (response != null) {
            String result = null;
            try {
                result = EntityUtils.toString(response);
                if (result == null || result.trim().isEmpty()) {
                    logger.error("Empty or null response received from Jira for non-migrated test case keys.");
                    return testCaseKeys;
                }
                JSONArray jsonArray = new JSONArray(result);
                for (int i = 0; i < jsonArray.length(); i++) {
                    JSONObject jsonObject = jsonArray.getJSONObject(i);
                    String key = jsonObject.getString("key");
                    logger.info("Key retrieved: " + key);
                    testCaseKeys.add(key);
                }
            } catch (ParseException | IOException e) {
                logger.error("Error while parsing the JSON response ", e);
            }
        } else {
            logger.error("Response is NULL while retrieving non-migrated keys from Jira.");
        }
        return testCaseKeys;
    }

    public JsonObject getJiraTestCaseDetails(String key) {
        JsonObject jiraJson = null;
        String url = jiraBaseURL + "/rest/atm/1.0/testcase/" + key;
        HttpEntity response = Utils.getJiraResponse(url, jiraApiKey);
        if (response != null) {
            try {
                String responseBody = EntityUtils.toString(response);
                logger.info("Testcase details for the key " + key + ": " + responseBody);
                jiraJson = JsonParser.parseString(responseBody).getAsJsonObject();
            } catch (ParseException | IOException e) {
                logger.error("Failed to retrieve JIRA testcase details for the key " + key, e);
            }
        } else {
            logger.error("Failed to get jira testcase details for the key " + key + "; Returning null");
        }
        return jiraJson;
    }

    public List<String> jiraAttachmentsDownload(String testcaseKey, String testType, String attachmentType) {
        List<String> fileAttachmentDownloadPaths = null;
        String testAttachmentUrl = null;
        if

 (testType.equals("testcase")) {
            testAttachmentUrl = jiraBaseURL + "/rest/atm/1.0/testcase/" + testcaseKey + "/attachments";
            logger.info("URL String for testcase attachments: " + testAttachmentUrl);
        } else if (testType.equals("teststep") && attachmentType.equals("file")) {
            testAttachmentUrl = jiraBaseURL + "/rest/atm/1.0/testcase/" + testcaseKey;
            logger.info("URL String for teststep attachments: " + testAttachmentUrl);
        } else if (testType.equals("teststep") && attachmentType.equals("embedded")) {
            testAttachmentUrl = jiraBaseURL + "/rest/atm/1.0/testcase/" + testcaseKey;
            logger.info("URL String for teststep attachments: " + testAttachmentUrl);
        } else {
            logger.error("Usage of jiraFileAttachmentsDownload is not correct. The argument value should be either testcase or teststep");
            return null;
        }

        HttpEntity response = Utils.getJiraResponse(testAttachmentUrl, jiraApiKey);
        if (response != null) {
            String result = null;
            try {
                result = EntityUtils.toString(response);
                if (result.trim().isEmpty() || result.equals("{}") || result.equals("[]")) {
                    logger.info("No Attachment URL found for the testcase key " + testcaseKey);
                } else {
                    logger.info("Attachment URL is found for the testcase key " + testcaseKey + "; JSON body: " + result);
                    if (testType.equals("testcase")) {
                        Map<String, String> testMap = Utils.pharseJsonGetAttachmentUrlAndName(result);
                        fileAttachmentDownloadPaths = Utils.downloadFileAttachmentFromJiraTestCase(testMap,
                                tcFileAttachmentDownloadLocation, jiraApiKey, testcaseKey);
                    } else if (testType.equals("teststep") && attachmentType.equals("file")) {
                        fileAttachmentDownloadPaths = Utils.downloadFileAttachmentFromTestStep(result, jiraApiKey,
                                tsFileAttachmentDownloadLocation, testcaseKey, jiraBaseURL);
                    } else if (testType.equals("teststep") && attachmentType.equals("embedded")) {
                        List<String> descriptionAttachmentDownloadPaths, testDataAttachmentDownloadPaths, expectedResultAttachmentDownloadPaths;
                        descriptionAttachmentDownloadPaths = Utils.downloadTestStepEmbeddedAttachments(result, jiraApiKey,
                                tsFileAttachmentDownloadLocation, testcaseKey, jiraBaseURL, "description");
                        testDataAttachmentDownloadPaths = Utils.downloadTestStepEmbeddedAttachments(result, jiraApiKey,
                                tsFileAttachmentDownloadLocation, testcaseKey, jiraBaseURL, "testData");
                        expectedResultAttachmentDownloadPaths = Utils.downloadTestStepEmbeddedAttachments(result, jiraApiKey,
                                tsFileAttachmentDownloadLocation, testcaseKey, jiraBaseURL, "expectedResult");
                        descriptionAttachmentDownloadPaths.addAll(testDataAttachmentDownloadPaths);
                        descriptionAttachmentDownloadPaths.addAll(expectedResultAttachmentDownloadPaths);
                        fileAttachmentDownloadPaths = descriptionAttachmentDownloadPaths;
                    } else {
                        logger.error("Usage of jiraFileAttachmentsDownload is not correct. The argument value should be either testcase or teststep");
                        return null;
                    }
                }
            } catch (ParseException | IOException e) {
                logger.error("Error while parsing the Json response ", e);
            }
        } else {
            logger.error("Response is NULL while retrieving non-migrated keys from JIRA. Returning NULL");
        }
        return fileAttachmentDownloadPaths;
    }
}
```

### `Utils.java`
```java
package com.optum.coe.automation.rally;

import org.apache.http.impl.client.HttpClientBuilder;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.rallydev.rest.RallyRestApi;
import com.rallydev.rest.request.CreateRequest;
import com.rallydev.rest.request.QueryRequest;
import com.rallydev.rest.response.CreateResponse;
import com.rallydev.rest.response.QueryResponse;
import com.rallydev.rest.util.Fetch;
import com.rallydev.rest.util.QueryFilter;
import org.apache.http.HttpEntity;

public class Utils {

    private static final Logger logger = LogManager.getLogger();

    public static JsonObject findOrCreateTag(RallyRestApi restApi, String tagName) throws IOException {
        QueryRequest tagRequest = new QueryRequest("Tag");
        tagRequest.setQueryFilter(new QueryFilter("Name", "=", tagName));
        QueryResponse tagResponse = restApi.query(tagRequest);

        if (tagResponse.getResults().size() > 0) {
            return tagResponse.getResults().get(0).getAsJsonObject();
        }

        JsonObject newTag = new JsonObject();
        newTag.addProperty("Name", tagName);

        CreateRequest createTagRequest = new CreateRequest("Tag", newTag);
        CreateResponse createTagResponse = restApi.create(createTagRequest);

        if (createTagResponse.wasSuccessful()) {
            return createTagResponse.getObject();
        } else {
            System.out.println("Error occurred creating tag:");
            for (String error : createTagResponse.getErrors()) {
                System.out.println(error);
            }
            return null;
        }
    }

    public static JsonObject createTestFolder(String[] folderHierarchy, String projectRef, String rallyBaseUrl,
                                              String rallyApiKey) {
        JsonObject lastFolder = null;
        String lastFolderRef = null;

        RallyRestApi restApi = null;
        try {
            restApi = new RallyRestApi(new URI(rallyBaseUrl), rallyApiKey);
            restApi.setApplicationName("CreateTestCaseApp");

            for (int i = 0; i < folderHierarchy.length; i++) {
                String folderName = folderHierarchy[i];
                if (folderName == null || folderName.trim().isEmpty()) {
                    logger.info("Invalid folder name encountered: '" + folderName + "'");
                    continue;
                }

                if (i == 0) {
                    QueryRequest parentFolderExistenceRequest = new QueryRequest("testfolder");
                    parentFolderExistenceRequest.setQueryFilter(new QueryFilter("Name", "=", folderName.trim())
                            .and(new QueryFilter("Parent", "=", "null")));
                    parentFolderExistenceRequest.setFetch(new Fetch("_ref", "Name", "Parent"));

                    QueryResponse parentQueryResponse = restApi.query(parentFolderExistenceRequest);

                    if (parentQueryResponse.wasSuccessful() && parentQueryResponse.getTotalResultCount() > 0) {
                        lastFolder = parentQueryResponse.getResults().get(0).getAsJsonObject();
                        lastFolderRef = lastFolder.get("_ref").getAsString();
                        logger.info("Parent folder already exists: " + lastFolderRef);
                    } else {
                        JsonObject newFolder = new JsonObject();
                        newFolder.addProperty("Name", folderName.trim());
                        newFolder.addProperty("Project", projectRef);

                        CreateRequest createFolderRequest = new CreateRequest("testfolder", newFolder);
                        CreateResponse createFolderResponse = restApi.create(createFolderRequest);

                        if (createFolderResponse.wasSuccessful()) {
                            lastFolderRef = createFolderResponse.getObject().get("_ref").getAsString();
                            newFolder.addProperty("_ref", lastFolderRef);
                            lastFolder = newFolder;
                            logger.info("Successfully created parent folder: " + lastFolderRef);
                        } else {
                            logger.error("Error occurred creating parent folder.");
                            for (String error : createFolderResponse.getErrors()) {
                                System.out.println(error);
                            }
                            break;
                        }
                    }
                } else {
                    QueryRequest subFolderExistenceRequest = new QueryRequest("testfolder");
                    subFolderExistenceRequest.setQueryFilter(new QueryFilter("Name", "=", folderName.trim())
                            .and(new QueryFilter("Parent", "=", lastFolderRef)));
                    subFolderExistenceRequest.setFetch(new Fetch("_ref", "Name", "Parent"));

                    QueryResponse subQueryResponse = restApi.query(subFolderExistenceRequest);

                    if (subQueryResponse.wasSuccessful() && subQueryResponse.getTotalResultCount() > 0) {
                        lastFolder = subQueryResponse.getResults().get(0).getAsJsonObject();
                        lastFolderRef = lastFolder.get("_ref").getAsString();
                        logger.info("Subfolder already exists: " + lastFolderRef);
                    } else {
                        JsonObject newFolder = new JsonObject();
                        newFolder.addProperty("Name", folderName.trim());
                        newFolder.addProperty("Project", projectRef);
                        newFolder.addProperty("Parent", lastFolderRef);

                        CreateRequest createFolderRequest = new CreateRequest("testfolder", newFolder);
                        CreateResponse createFolderResponse = restApi.create(createFolderRequest);

                        if (createFolderResponse.wasSuccessful()) {
                            lastFolderRef = createFolderResponse.getObject().get("_ref").getAsString();
                            newFolder.addProperty

("_ref", lastFolderRef);
                            lastFolder = newFolder;
                            logger.info("Successfully created subfolder: " + lastFolderRef);
                        } else {
                            logger.error("Error occurred creating subfolder");
                            for (String error : createFolderResponse.getErrors()) {
                                System.out.println(error);
                            }
                            break;
                        }
                    }
                }
            }

            return lastFolder;

        } catch (Exception e) {
            logger.error("Exception occurred while creating test folder structure in Rally.", e);
            return null;
        } finally {
            if (restApi != null) {
                try {
                    restApi.close();
                } catch (Exception e) {
                    logger.error("Error occurred while closing RallyRestApi.", e);
                }
            }
        }
    }

    public static Map<String, String> pharseJsonGetAttachmentUrlAndName(String jsonResponse) {
        Map<String, String> attachmentMap = new HashMap<>();
        JSONArray jArrayResponse = new JSONArray(jsonResponse);
        for (int i = 0; i < jArrayResponse.length(); i++) {
            JSONObject jsonObject = jArrayResponse.getJSONObject(i);
            String url = jsonObject.getString("url");
            String name = jsonObject.getString("filename");
            attachmentMap.put(url, name);
        }
        return attachmentMap;
    }

    public static List<String> downloadFileAttachmentFromJiraTestCase(Map<String, String> attachmentMap,
                                                                      String tcAttachmentDownloadLocation, String jiraApiKey, String testcaseKey) throws IOException {

        List<String> filePaths = new ArrayList<>();
        Path path = Paths.get(tcAttachmentDownloadLocation);
        if (!Files.exists(path)) {
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                logger.error("Failed to create directories for attachment download location.", e);
            }
        }

        for (Map.Entry<String, String> entry : attachmentMap.entrySet()) {
            String fileUrl = entry.getKey();
            String fileName = entry.getValue();
            HttpEntity response = Utils.getJiraResponse(fileUrl, jiraApiKey);

            if (response != null) {
                try (InputStream in = response.getContent()) {
                    Path filePath = Paths.get(tcAttachmentDownloadLocation + "/" + fileName);
                    Files.copy(in, filePath, StandardCopyOption.REPLACE_EXISTING);  // Overwrite if file exists
                    filePaths.add(filePath.toString());
                    EntityUtils.consume(response);
                    logger.info("File downloaded from Jira to tcAttachmentDownloadLocation. File Name: " + fileName);
                } catch (IOException e) {
                    logger.error("Failed to download the file attachments from Jira for Testcase level", e);
                }
            } else {
                logger.error("Failed to download the file attachment " + fileName
                        + " from Jira for Testcase level. No Entity response found");
            }
        }
        return filePaths;
    }

    public static String downloadFileFromUrl(String fileURL, String destinationFile) throws IOException {
        logger.debug("Attempting to download file from URL: " + fileURL + " to: " + destinationFile);
        URL url = new URL(fileURL);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setRequestMethod("GET");

        try (InputStream inputStream = connection.getInputStream()) {
            Path filePath = Paths.get(destinationFile);
            Files.copy(inputStream, filePath, StandardCopyOption.REPLACE_EXISTING);  // Overwrite if file exists
            logger.info("Downloaded file from URL: " + fileURL + " to: " + destinationFile);
            return filePath.toString();
        } catch (IOException e) {
            logger.error("Failed to download file from URL: " + fileURL, e);
            throw e;
        }
    }

    public static List<String> downloadFileAttachmentFromTestStep(String jsonResponse, String apiToken,
                                                                  String testStepFileAttachmentLocationToBeSaved, String tC_Id, String baseURL) throws IOException {
            List<String> filePaths = new ArrayList<>();
        JSONObject jsonObject = new JSONObject(jsonResponse);
        JSONArray stepsArray = jsonObject.getJSONObject("testScript").getJSONArray("steps");
        Path path = Paths.get(testStepFileAttachmentLocationToBeSaved);
        if (!Files.exists(path)) {
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                logger.error("Failed to create directories for test step attachment download location.", e);
            }
        }

        for (int i = 0; i < stepsArray.length(); i++) {
            JSONObject stepObject = stepsArray.getJSONObject(i);
            int index = stepObject.getInt("index");
            int stepNumber = index + 1;
            if (stepObject.has("attachments")) {
                JSONArray attachmentsArray = stepObject.getJSONArray("attachments");
                for (int j = 0; j < attachmentsArray.length(); j++) {
                    JSONObject attachmentObject = attachmentsArray.getJSONObject(j);
                    int attachmentID = attachmentObject.getInt("id");
                    int attachmentNumber = j + 1;
                    String attachmentFileName = attachmentObject.getString("name");
                    String testStepAttachmentUrl = baseURL + "/rest/tests/1.0/attachment/" + attachmentID;
                    HttpEntity response = Utils.getJiraResponse(testStepAttachmentUrl, apiToken);
                    if (response != null) {
                        try (InputStream in = response.getContent()) {
                            Path filePath = Paths.get(testStepFileAttachmentLocationToBeSaved + "/" + stepNumber + "_" + attachmentNumber + "_" + attachmentFileName);
                            Files.copy(in, filePath, StandardCopyOption.REPLACE_EXISTING);  // Overwrite if file exists
                            filePaths.add(filePath.toString());
                            EntityUtils.consume(response);
                            logger.info("File downloaded from Jira to testStepFileAttachmentLocation. File Name: " + attachmentFileName);
                        } catch (IOException e) {
                            logger.error("Failed to download the file attachments from Jira for Testcase level", e);
                        }
                    } else {
                        logger.error("Failed to download the file attachment " + attachmentFileName
                                + " from Jira for Testcase level. No Entity response found");
                    }
                }
            }
        }
        return filePaths;
    }

    public static List<String> downloadTestStepEmbeddedAttachments(String jsonResponse, String apiToken,
            String testStepAttachmentLocationToBeSaved, String tC_Id, String baseURL, String columnName)
            throws IOException {
        List<String> filePaths = new ArrayList<>();

        // Validate the response to ensure it starts with a '{'
        if (jsonResponse == null || !jsonResponse.trim().startsWith("{")) {
            logger.error("Received invalid JSON response or non-JSON content. Skipping processing.");
            return filePaths;
        }

        try {
            JSONObject jsonObject = new JSONObject(jsonResponse);
            JSONArray stepsArray = jsonObject.getJSONObject("testScript").getJSONArray("steps");
            Path path = Paths.get(testStepAttachmentLocationToBeSaved);
            if (!Files.exists(path)) {
                try {
                    Files.createDirectories(path);
                } catch (IOException e) {
                    logger.error("Failed to create directories for embedded attachment download location.", e);
                }
            }

            for (int i = 0; i < stepsArray.length(); i++) {
                JSONObject stepObject = stepsArray.getJSONObject(i);
                int index = stepObject.getInt("index");
                int stepNumber = index + 1;
                if (stepObject.has(columnName)) {
                    String htmlContent = stepObject.getString(columnName);
                    Document doc = Jsoup.parse(htmlContent);
                    Elements imgElements = doc.select("img");
                    if (!imgElements.isEmpty()) {
                        int imageCount = 0;
                        for (Element img : imgElements) {
                            String imageUrl = img.attr("src");
                            if (!imageUrl.isEmpty()) {
                                imageUrl = imageUrl.trim();
                                imageUrl = imageUrl.replaceAll("\\.\\./", "");
                                if (imageUrl.contains("\"")) {
                                    imageUrl = imageUrl.replace("\"", "");
                                }

                                imageCount++;
                                String extractUrl = imageUrl.startsWith("/") ? imageUrl.substring(1) : imageUrl;
                                String absoluteUrl = baseURL.endsWith("/") ? baseURL + extractUrl : baseURL + "/" + extractUrl;

                                logger.info("Constructed URL for embedded image download: " + absoluteUrl);

                                HttpEntity response = Utils.getJiraResponse(absoluteUrl, apiToken);
                                if (response != null) {
                                    try (InputStream in = response.getContent()) {
                                        Path filePath = Paths.get(testStepAttachmentLocationToBeSaved + "/" + stepNumber + "_" + imageCount + "_" + "_EmbeddedFile_" + columnName + ".png");
                                        Files.copy(in, filePath, StandardCopyOption.REPLACE_EXISTING);
                                        filePaths.add(filePath.toString());
                                        EntityUtils.consume(response);
                                        logger.info("File downloaded from Jira to testStepAttachmentLocation. File Name: " + stepNumber + "_" + imageCount + "_" + "_EmbeddedFile_" + columnName + ".png");
                                    } catch (IOException e) {
                                        logger.error("Failed to download the file attachment " + stepNumber + "_" + imageCount + "_" + "_EmbeddedFile_" + columnName + " from Jira for test step level", e);
                                    }
                                } else {
                                    logger.error("Failed to download the file attachment from Jira. No Entity response found for URL: " + absoluteUrl);
                                }
                            }
                        }
                    }
                } else {
                    logger.error("No valid argument is passed to the method. It should be either description OR testData OR expectedResult");
                }
            }
        } catch (JSONException e) {
            logger.error("Error while parsing JSON response: " + jsonResponse, e);


        }
        return filePaths;
    }

    public static void deleteAttachmentFileFromLocal(List<String> filePaths) {
        for (String filePath : filePaths) {
            File file = new File(filePath);
            if (file.exists()) {
                file.delete();
                logger.info("The file " + filePath + " is deleted for the next attachment download run.");
            }
        }
    }

    public static HttpEntity getJiraResponse(String url, String apiKey) {
        CloseableHttpClient connection = HttpClientBuilder.create()
                .setDefaultRequestConfig(RequestConfig.custom()
                        .setSocketTimeout(10000)  // Increase socket timeout
                        .setConnectTimeout(10000) // Increase connection timeout
                        .setConnectionRequestTimeout(10000) // Increase request timeout
                        .build())
                .build();

        HttpGet request = new HttpGet(url);
        request.setHeader("Authorization", "Bearer " + apiKey);
        CloseableHttpResponse response = null;
        try {
            response = connection.execute(request);
        } catch (ClientProtocolException e) {
            logger.error("Error occurred in Jira connection while connecting " + url, e);
        } catch (IOException e) {
            logger.error("Error occurred in Jira connection while connecting " + url, e);
        }
        HttpEntity entity = response.getEntity();
        if (entity != null) {
            logger.info("Successfully returned HttpEntity response for the URL " + url);
            return entity;
        } else {
            logger.error("Error occurred. HttpEntity is null and no response is received for the URL." + url);
            return null;
        }
    }

    public static String constructAttachmentUrls(List<String> attachmentPaths) {
        StringBuilder attachmentUrls = new StringBuilder();
        for (String path : attachmentPaths) {
            attachmentUrls.append("<br/><img src=\"").append(path).append("\" />");
        }
        return attachmentUrls.toString();
    }

    public static String getJsonString(JsonObject jsonObject, String key) {
        JsonElement element = jsonObject.get(key);
        if (element != null && !element.isJsonNull()) {
            if (element.isJsonArray()) {
                StringBuilder dataBuilder = new StringBuilder();
                JsonArray dataArray = element.getAsJsonArray();
                for (JsonElement jsonElement : dataArray) {
                    if (dataBuilder.length() > 0) {
                        dataBuilder.append(", ");
                    }
                    dataBuilder.append(jsonElement.getAsString());
                }
                return dataBuilder.toString();
            } else {
                return element.getAsString();
            }
        } else {
            logger.warn("Key {} not found or is null in JsonObject", key);
            return "";
        }
    }
}
```

These updates should address the issues related to JSON validation, retrying for concurrency conflicts, and error handling. Let me know if there are further changes you would like to make!
